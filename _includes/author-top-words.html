{% assign data = site.data.yazarlar[include.author_slug] %}
{% if data == nil %}
  <p>Data not found for <code>{{ include.author_slug }}</code>.</p>
{% else %}
  {% assign freq = data.total_stats %}
  <div id="chart-{{ include.author_slug }}" style="width:100%;height:520px"></div>
  <script>
  (function() {
    const elId = "chart-{{ include.author_slug }}";
    const raw = {{ freq | jsonify }};
    const hideStop = {{ include.hide_stopwords | default: false }};
    const topN = {{ include.top_n | default: 30 }};
    const mode = "{{ include.normalize | default: 'none' }}"; // none, relative, percent, perK, per10K, perM, zscore, log

    const stop = new Set(["ve","de","da","bu","bir","mi","mı","mu","mü","ki","ile","için","çok","ama","fakat","ya","ne","o","hem","her","gibi","şu","şey"]);

    // Build array
    let arr = Object.entries(raw);
    if (hideStop) arr = arr.filter(([w]) => !stop.has(w));

    // Stats for normalization
    const counts = arr.map(([, c]) => c);
    const total = counts.reduce((a, b) => a + b, 0);
    const denom = Math.max(1, counts.length);
    const mean = counts.length ? counts.reduce((a, b) => a + b, 0) / counts.length : 0;
    const std = Math.sqrt(counts.reduce((s, c) => s + Math.pow(c - mean, 2), 0) / Math.max(1, counts.length - 1));

    function norm(c) {
      switch (mode) {
        case 'relative': return c / Math.max(1, total);
        case 'percent':  return (c / Math.max(1, total)) * 100;
        case 'perK':     return (c / Math.max(1, total)) * 1_000;
        case 'per10K':   return (c / Math.max(1, total)) * 10_000;
        case 'perM':     return (c / Math.max(1, total)) * 1_000_000;
        case 'zscore':   return std > 0 ? (c - mean) / std : 0;
        case 'log':      return Math.log10(c + 1);
        default:         return c; // 'none'
      }
    }

    // Attach normalized value, sort by it, and keep topN
    let scored = arr.map(([w, c]) => [w, c, norm(c)]);
    scored.sort((a, b) => b[2] - a[2]);
    scored = scored.slice(0, topN);

    // Prepare data (reverse so the largest is at the top)
    const words  = scored.map(([w])     => w).reverse();
    const values = scored.map(([, , v]) => v).reverse();
    const rawCounts = scored.map(([, c]) => c).reverse();

    // Colors per word
    const colors = words.map((_, i) => {
      const hue = (i * 137.508) % 360; // golden angle
      return `hsl(${hue}, 60%, 55%)`;
    });

    // Axis label by mode (define BEFORE plotting)
    const xLabelMap = {
      none: "Frekans",
      relative: "Göreli Frekans",
      percent: "Yüzde (%)",
      perK: "1.000 Kelimede",
      per10K: "10.000 Kelimede",
      perM: "Milyonda",
      zscore: "Z-Skoru",
      log: "log10(Frekans+1)"
    };
    const xLabel = xLabelMap[mode] || "Frekans";

    function render() {
      Plotly.newPlot(elId, [{
        x: values,
        y: words,
        type: "bar",
        orientation: "h",
        marker: { color: colors },
        // Show both normalized value and raw count in hover
        customdata: rawCounts,
        hovertemplate: "%{y}<br>" + xLabel + ": %{x:.4g}<br>Ham: %{customdata:,}<extra></extra>"
      }], {
        margin: { l: 160, r: 10, t: 10, b: 40 },
        xaxis: { title: xLabel },
        yaxis: { automargin: true }
      }, {
        displayModeBar: false,
        responsive: true
      });
    }

    // Wait for Plotly if needed
    if (window.Plotly) {
      render();
    } else {
      window.addEventListener('load', render);
    }
  })();
  </script>

{% endif %}
